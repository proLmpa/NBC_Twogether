<h1>
  
> 협업 도구 Twogether 만들기 : <br> 내일배움캠프 Spring 최종 팀 프로젝트 2조

</h1>

<br>

  <h6>back-end</h6>
<p style="display: block;">
    <img src="https://img.shields.io/badge/java-007396?style=for-the-badge&logo=java&amp;logoColor=white">
    <img src="https://camo.githubusercontent.com/c1fc168684171582321954905e8b9dc4f59810243ed85e645f3b7938ee3145cb/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6d7973716c2d3434373941313f7374796c653d666f722d7468652d6261646765266c6f676f3d6d7973716c266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&amp;logo=mysql&amp;logoColor=white">
    <img src="https://img.shields.io/badge/H2-0000bb?style=for-the-badge&logo=H2&amp;logoColor=white">
    <img src="https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white">
    <img src="https://img.shields.io/badge/Spring-6DB33F.svg?style=for-the-badge&logo=Spring&logoColor=white">
    <img src="https://img.shields.io/badge/Spring%20Security-6DB33F.svg?style=for-the-badge&logo=Spring-Security&logoColor=white">
    <img src="https://img.shields.io/badge/Spring%20Boot-6DB33F.svg?style=for-the-badge&logo=Spring-Boot&logoColor=white">
    <img src="https://camo.githubusercontent.com/a4797e4acda6db88d63a7a0ef7332bd6a3e7cf9282fa0d7d1af6605efe11929c/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537072696e672044617461204a50412d3644423333463f7374796c653d666f722d7468652d6261646765266c6f676f3d266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/badge/Spring Data JPA-6DB33F?style=for-the-badge&amp;logo=&amp;logoColor=white">
    <img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&logo=amazon-aws&logoColor=white">
    <img src="https://img.shields.io/badge/AWS EC2-f90?style=for-the-badge&logo=amazon-awsec2&logoColor=white">
    <img src="https://img.shields.io/badge/AWS CodeDeploy-f90?style=for-the-badge&logo=amazon-aws-CodeDeploy-f90&logoColor=white">
    <img src="https://img.shields.io/badge/AWS RDS-f90?style=for-the-badge&logo=amazon-aws-RDS-f90&logoColor=white">
    <img src="https://img.shields.io/badge/AWS S3-f90.svg?style=for-the-badge&logo=amazon-aws-S3&logoColor=white">
    <img src="https://img.shields.io/badge/AWS ElastiCache-f90.svg?style=for-the-badge&logo=ElastiCache&logoColor=white">
    <img src="https://camo.githubusercontent.com/78f3152017f7dae410d842069791c2518dfc6d1a842e50b99ad5c4ed30ee0ae4/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f48696265726e6174652d3539363636433f7374796c653d666f722d7468652d6261646765266c6f676f3d68696265726e617465266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/badge/Hibernate-59666C?style=for-the-badge&amp;logo=hibernate&amp;logoColor=white">
    <img src="https://camo.githubusercontent.com/c0f71772804c86d0f144ce923027aff25e8d761c6b791d2de6698607e21c5465/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f677261646c652d3032333033413f7374796c653d666f722d7468652d6261646765266c6f676f3d677261646c65266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&amp;logo=gradle&amp;logoColor=white">
    <img src="https://camo.githubusercontent.com/5af78a02d0f7a4b8a759f9580ce718287a0626f80a55c38ad0bac83e0b31f94d/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4a57542d3030303030303f7374796c653d666f722d7468652d6261646765266c6f676f3d6a736f6e776562746f6b656e73266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/badge/JWT-000000?style=for-the-badge&amp;logo=jsonwebtokens&amp;logoColor=white">
  </p>

  <h6>front-end</h6>
  <p style="display: block;">
    <img src="https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white">
    <img src="https://img.shields.io/badge/css3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white">
    <img src="https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E">
    <img src="https://img.shields.io/badge/Thymeleaf-005f0f.svg?style=for-the-badge&logo=Thymeleaf-&logoColor=white">
  </p>
  
  <h6>tool</h6>
  <p style="display: block;">
    <img src="https://camo.githubusercontent.com/699cfd7f3bb6a4e1764449f9b0da88a99a8d46bee71b93752b15ee8fbca5026a/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f496e74656c6c694a20494445412d3030303030303f7374796c653d666f722d7468652d6261646765266c6f676f3d496e74656c6c694a2049444541266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/badge/IntelliJ IDEA-000000?style=for-the-badge&amp;logo=IntelliJ IDEA&amp;logoColor=white">
    <img src="https://img.shields.io/badge/GitHub-181717.svg?style=for-the-badge&logo=GitHub&logoColor=white">
    <img src="https://img.shields.io/badge/github%20actions-%232671E5.svg?style=for-the-badge&logo=githubactions&logoColor=white">
    <img src="https://img.shields.io/badge/Git-F05032.svg?style=for-the-badge&logo=Git&logoColor=white">
    <img src="https://camo.githubusercontent.com/3f0e26b0951bab845a1bb9a7198ecca0da272e462921b6edd85879f3673b6927/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f506f73746d616e2d4646364333373f7374796c653d666f722d7468652d6261646765266c6f676f3d706f73746d616e266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/badge/Postman-FF6C37?style=for-the-badge&amp;logo=postman&amp;logoColor=white">
    <img src="https://img.shields.io/badge/figma-%23F24E1E.svg?style=for-the-badge&logo=figma&logoColor=white">
    <img src="https://img.shields.io/badge/Swagger-85EA2D.svg?style=for-the-badge&logo=Swagger&logoColor=black">
    <img src="https://camo.githubusercontent.com/c37f52fc7f77f8a8fd16a733a91c75278dcb3149e14c24a2203d7f7217bb4643/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f536c61636b2d3441313534423f7374796c653d666f722d7468652d6261646765266c6f676f3d536c61636b266c6f676f436f6c6f723d7768697465" data-canonical-src="https://img.shields.io/badge/Slack-4A154B?style=for-the-badge&amp;logo=Slack&amp;logoColor=white">
    <img src="https://img.shields.io/badge/Notion-000000.svg?style=for-the-badge&logo=Notion&logoColor=white">
    <img src="https://img.shields.io/badge/Trello-%23026AA7.svg?style=for-the-badge&logo=Trello&logoColor=white">
  </p>

<br><br>

<h3>01. 프로젝트 소개</h3>

* 주제 : `칸반 보드 기반의 협업 도구 만들기`
* 선정 배경 : 최종 프로젝트 이전 마지막 프로젝트가 협업 도구 만들기였는데, 해당 프로젝트가 짧은 기간만 하고 지나치기에는 너무 아쉽고 `나중에 직접 사용하고 싶을 정도의 협업 도구를 만들어보자!` 라는 마음에서 이 주제를 선정하게 되었습니다.
* 사이트 바로가기 : www.twogetherwork.com
* Swagger : http://www.twogetherwork.com/swagger-ui/index.html
* ERD :
  <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/683a5763-d601-4755-83e6-43327bf9e403">
* Architecture : 
  <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/2ea42782-53d6-4875-932a-67c07654d584">

<br><br>

<h3>02. 팀 구성 및 담당</h3>

| 팀 구성 | 역할 | 담당한 업무 |
|------|---------|------------------------------------------------------|
| 김희열 | 팀장 | GithubAction CI/CD, Redis - RefreshToken, 프론트 드래그&드랍, 카드 댓글, 라벨링 백엔드 기능 구현 |
| 한지훈 | 부팀장 | 덱, 카드 백엔드 ~ 프론트 기능 구현, 통합 테스트 코드 H2 환경 설정 및 작성 |
| 송어진 | 팀원 | 보드 백엔드 기능 구현, 협업자, 개인프로필, 알림 백엔드 ~ 프론트 기능 구현 |
| 양소영 | 팀원 | 워크스페이스, 카드 체크리스트 백엔드 기능 구현, 모든 CSS 작업 |

<br><br>

<h3>03. 구현 기능</h3>

<details>
<summary>워크스페이스 기본 기능</summary>
<div markdown="1">
  
 * 사용자가 회원 가입 시 생성 가능한 가장 큰 작업 공간입니다. 
 * 큰 단위의 작업을 모아두기 위해 필요한 공간입니다. (ex. 프로젝트, 일정)
   <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/65dbf30e-f264-444c-a806-82a0661cf59b">

</div>
</details>

<details>
<summary>보드 기본 기능</summary>
<div markdown="1">
  
 * 워크스페이스 내에서 생성 가능한 작업 공간입니다. 
 * 워크스페이스 내 작업을 구분하기 위해 필요한 공간입니다. (ex. 백엔드/프론트엔드/기획, 회사 일정/개인 일정)
   <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/0b763c0f-ceef-4b6f-bc9d-dd4e6deb493c">
 
</div>
</details>
        
<details>
<summary>덱 기본 기능</summary>
<div markdown="1">
  
 * 보드 내에서 생성 가능한 작업 공간입니다.
 * 보드 내 작업을 정리하기 위해 필요한 공간입니다. (ex. To do/In progress/Done, 첫째 주/둘째 주/셋째 주/넷째 주/다섯째 주)
 * 각 덱의 순서를 중요도, 편의 상의 배치를 위해 순서를 임의로 바꿀 수 있습니다.
   <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/199b7ea8-5818-49bb-ba88-6002bdc41be2">
</div>
</details>

<details>
<summary>카드 기본 기능</summary>
<div markdown="1">
  
 * 덱 내에서 생성 가능한 작업 공간입니다.
 * 덱 내 작업을 세분화하기 위해 필요한 공간입니다. (ex. 댓글/로그인/카드 이동, 보고서 작성하기/병원 가기)
 * 각 카드의 순서도 임의로 바꿀 수 있으며, 다른 보드로 이동도 가능합니다.
 * 각 카드 내 작업 현황을 알기 쉽게 만들어 주는 체크 리스트가 있습니다.
 * 각 카드를 덱 외의 방법으로 분류하기 위한 라벨 기능, 카드 작업자 할당 기능, 마감일 기능도 있으나 아직 프론트에는 구현이 안되어 있습니다.
   <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/3d730d4a-9913-4539-8d06-b7acfdae38dc">
   
</div>
</details>

<details>
<summary>카드와 덱 상세 기능 : 보관/복구</summary>
<div markdown="1">
  
 * 카드와 덱은 실질적으로 작업할 때 가장 많이 생성되고, 삭제되는 요소입니다.
 * 하지만 ‘협업’ 프로젝트 도구인 만큼 여러 사람이 같이 관리하다 보니 실수로, 소통 오류로 삭제되는 일이 빈번하고, 협의 하에 삭제했으나 나중에 다시 필요해지는 경우도 생기기 때문에 해당 요소들을 바로 삭제하는 것이 아닌, 보관 과정을 거치게 합니다.
 * 보관된 덱과 카드는 실제 작업 환경에서는 보이지 않지만 설정 창에서 쉽게 조회하고, 복구할 수 있습니다.
   <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/eaa3fc92-5261-46ea-9df5-ef394b3f6732">
</div>
</details>
        
<details>
<summary>워크스페이스/보드 초대 기능</summary>
<div markdown="1">
  
 * 워크스페이스, 보드에는 각각의 초대 기능이 있습니다.
 * 워크스페이스에서 초대된 유저는 해당 워크스페이스 내 보드들을 전부 조회할 수 있으며, 작업할 수 있습니다.
 * `보드에서 초대된 유저는 해당 보드만 작업할 수 있으며, 해당 보드가 포함된 워크스페이스의 다른 보드들에는 접근 권한이 없습니다.`
   * 워크스페이스 협업자 초대 기능   
     <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/9e1da668-a44e-4666-b405-1f511c774512">
   * 보드 협업자 초대 기능 : 권한 제어 목적
     <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/5a717342-76d4-45c5-948a-879a1f9b5b75">
   
</div>
</details> 
  
<details>
<summary>개인 프로필 기능</summary>
<div markdown="1">
  
 * 상단의 프로필 이미지를 클릭하면 좌측에 개인 프로필 창이 나타납니다. 
 * 프로필 정보, 이미지 수정 버튼을 눌러 자신의 문구와 멋진 사진을 등록하면 정보와 사진과 업데이트 됩니다.
   <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/a5a21234-299b-47b1-9004-f89fe356aa0b">
</div>
</details> 

<details>
<summary>알림 기능</summary>
<div markdown="1">
  
 * `특정 이벤트`가 발생했을 때 이벤트를 전송하고, 읽지 않은 이벤트가 있다면 프로필에 초록색 불이 들어옵니다.
   <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/fd9b5ddf-8913-40f6-a1b7-74a61760a4ac">
   <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/0b564e67-1529-4148-a11c-2102147129a4">
   
    <details>
    <summary>특정 이벤트의 종류</summary>
    <div markdown="1">
      
    * 카드 설명 수정 이벤트
    * 카드 마감일 수정 이벤트
    * 카드 댓글 생성 이벤트
    * 카드 작업자 할당 이벤트
    * 보드 협업자 초대 이벤트
    * 워크스페이스 협업자 초대 이벤트
      <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/db77ff55-134b-49c3-98d3-3a9912f8a7c7">
      <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/dbb50d18-6564-4783-a78c-9df65a2371cd">
      
    </div>
    </details>      

    <details>
    <summary>알림 버튼의 종류</summary>
    <div markdown="1">
      
    * 만약 알림을 모두 읽음 상태로 바꾸면 아래와 같이, 알림 배지의 형광 초록 불이 꺼집니다.
      <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/1e3d610b-4e94-49a2-9fc1-ac4eb159abd9">
      
    * 알림 삭제 버튼을 누르면 “알림을 삭제하시겠습니까?”라는 문구를 통해 확인을 받은 후, 확인을 누르면 알림이 삭제 됩니다.
      <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/3104cb3b-a5bf-441c-af52-380818d21cf5">
      
    * 알림이 없거나 알림을 모두 삭제한 경우에는 아래와 같이 “도착한 알림이 없습니다.”라는 문구로 대체됩니다.
      <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/01364406-4d7a-4b1c-91b7-a1b50810addc">
      
    </div>
    </details>      
</div>
</details> 

<br><br>

<h3>04. 트러블 슈팅</h3>

<details>
<summary>더미 데이터를 통한 테스트 코드 실행</summary>
<div markdown="1">
  <br>
  
* ❗문제 발생
  * 각 메서드를 실행할 때마다 발생하는 공통 로직이 존재하여 이를 @BeforeEach 로 각 메서드를 실행할 때마다 실행하고자 함.      
  * 이를 해결하기 위해 기존에는 아래의 방식으로 데이터를 DB에 저장함.
  * 단일 인스턴스를 생성할 때야 편하지만 복수의 인스턴스를 생성해야 할 때는 코드의 길이가 길어지고 번잡해지는 문제를 발견함.
  * e.g. 보드 관련된 로직을 테스트하기 위해선 회원 가입과 워크스페이스 생성 작업이 사전에 이루어져야 한다.
        
        // UserServiceTest.java

        @BeforeEach
        void signUp() {
            // given
            String email = "user2024@email.com";
            String password = "user123!@#";
            boolean admin = false;
            String adminToken = "";
        
            encoder = new BCryptPasswordEncoder();
            SignupRequestDto request = SignupRequestDto.builder().email(email).password(password)
                .admin(admin).adminToken(adminToken).build();
        
            // when
            User signed = userService.signup(request);
        
            // then
            Assertions.assertEquals(email, signed.getEmail());
            Assertions.assertTrue(encoder.matches(password, signed.getPassword()));
            Assertions.assertEquals(UserRoleEnum.USER, signed.getRole());
            user = signed;
        }
    
<br>
        
* ❓ 해결책 탐구
  * 더미 데이터 : 대용량 데이터를 테스트 실행 전에 준비할 필요가 있거나 연쇄적으로 매핑된 객체들을 순서대로 미리 만들어 놓기에 편리함.

<br>
        
* ➡️ 결과
        
  * 첫째, 테스트 전에 SQL을 통해 더미 데이터 생성하고, h2에 저장
        
           // data.sql
       
        	-- workspace 테이블 생성
        	CREATE TABLE IF NOT EXISTS workspace (
        	    id LONG PRIMARY KEY,
        	    title VARCHAR(50),
        	    icon VARCHAR(50),
        	    user_id LONG,
        	    created_at datetime,
        	    modified_at datetime,
        	    FOREIGN KEY (user_id) REFERENCES users(id)
        	);
        	
        	-- 더미 workspace 데이터 삽입
        	INSERT INTO workspace (id, title, icon, user_id, created_at, modified_at) VALUES
        	(1, 'Workspace 1', 'test', 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00'),
        	(2, 'Workspace 2', 'test', 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00'),
        	(3, 'Workspace 1', 'test', 2, '2023-01-01 00:00:00', '2023-01-01 00:00:00');
        
  * 둘째, 테스트 코드에서 더미 데이터 호출
        
            // BoardServiceTest.java
    
        		@BeforeEach
            void setUp() {
                user = userRepository.findById(1L).orElse(null);
                wp1 = wpRepository.findById(1L).orElse((null));
                wp2 = wpRepository.findById(2L).orElse((null));
                wp3 = wpRepository.findById(3L).orElse((null));
            }
</div>
</details>
        
<details>
<summary>CI/CD</summary>
<div markdown="1">

* ❗제안

  1. Github Actions로 빌드-테스트 자동화하는 CI를 구축한 것에서 더 나아가 배포 자동화까지 해보는 것이 좋을 것 같아 Githuh Actions를 통한 CD 사용을 제안
  2. 배포를 담당할 서버가 AWS EC2 서비스라는 점에서 연동이 잘 되어 배포가 쉽고 빠른 AWS CodeDeploy 사용을 결정

<br>        
        
* ⛵ 적용 과정 <br>
  1. 파일이 배포될 AWS 서버 환경 준비
        - AWS EC2, RDS, ElastiCache 서비스 구매
        - 서버에 mysql, redis-cli, codedeploy-agent 등 필요한 서비스 설치
        - 각 서비스에 보안 그룹 및 IAM 역할 설정하기
      
  2. AWS CodeDeploy 설정
        - 배포 애플리케이션 및 배포 그룹 생성
      
  3. Github Actions CD 환경 준비
        - CD 환경을 위한 Github Actions secrets 추가
        - AWS CodeDeploy 배포를 위한 yml 파일 준비
        - AWS EC2가 배포 파일을 실행하도록 yml과 sh 파일 준비
  
  <br>            
  
* ➡️ 결과 : AWS CodeDeploy 적용 완료!
  <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/8ca5e5f3-4aac-4fb9-af96-7e54d7ecaf10">

  <br>            

</div>
</details>

<details>
<summary>Lazy Loading 방식</summary>
<div markdown="1">
  
* ❗문제 발생
  : 보드 협업자로 초대된 경우, 자동으로 워크스페이스 협업자로도 등록하는 로직에서 `WorkspaceCollaborator DB(워크스페이스 협업자)`에 데이터가 담기지 않는 문제 발생
        
        // 문제가 발생한 코드
        
            public void autoInviteWpCol(User user, Long wpId) {
                Workspace foundWorkspace = findWpById(wpId);
        
                // 이미 등록된 사용자 초대당하기 불가
                if (wpColRepository.existsByWorkspaceAndEmail(foundWorkspace, user.getEmail())) {
                    throw new CustomException(CustomErrorCode.WORKSPACE_COLLABORATOR_ALREADY_EXISTS);
                }
        
                // 워크스페이스 협업자로 등록
                User invitedUser = findUser(user.getEmail());
                WorkspaceCollaborator newWpCol = WpColRequestDto.toEntity(invitedUser, foundWorkspace);
        
                // 아이디 수동 할당 - 데이터가 덮어 씌어지는 문제 방지
                newWpCol.assignNewId();
                wpColRepository.save(newWpCol);
            }

<br>    
    
* ❓해결책 탐구
  * `의심 01.` <br>아래의 코드에서 foundWorkspace 변수와 invitedUser 변수의 필드에 null 값이 담기고, $$_hibernate_interceptor 안에 실제 데이터가 담기는 현상이 발생했다. <br><br>우선 Hibernate Interceptor가 무엇인지 알아보았다. Hibernate가 엔티티의 상태를 추적하고 데이터베이스 작업 전/후에 사용자 정의 로직을 실행하는 역할을 한다고 한다. 현 문제 상황과 연관이 있을 가능성이 높아 보이지는 않는다..!

  <br><br>
        
  * `의심 02.` Lazy Loading과 관련된 문제일 수 있다는 가정 하에 해결책을 탐구하기 시작했다. 우선 Lazy Loading은 연관된 엔티티를 필요한 시점에 데이터베이스에서 로드 하는 방식으로, 현 문제 상황과 관련이 있을 지도 모른다고 생각한 이유는 다음과 같다.<br><br>둘의 연관성을 살펴보면.. JPA Entity를 로드할 때 연관된 엔티티를 FetchType.LAZY로 설정한 경우, FetchType.LAZY로 설정된 연관 엔티티는 실제로 필요한 시점에 데이터베이스에서 가져오기 때문에 해당 필드에 접근이 생기기 전에는 초기화되지 않는다.<br><br>즉, Lazy Loading 방식을 사용하면 JPA는 연관 관계를 맺고 있는 Workspace Collaborator db에 접근하는 것을 지연시키고..<br><br>이로 인해, workspace를 통해 연관된 엔티티를 거쳐서 wpColRepository에 직접 user를 save 시키더라도, workspace와 연관 관계를 맺고 있는 WorkspaceCollaborator 필드에 접근하는 로직이 없어서, Lazy Loading에 의해 WorkspaceCollaborator db 접근이 지연될 수 있을 거라 생각한 것이다.
        
<br><br>
    
* ✅ 문제 확인 <br>Lazy Loading 방식을 사용하면 JPA는 연관 관계를 맺고 있는 WorkspaceCollaborator DB에 접근하는 것을 지연시킨다.

<br><br>
    
* 💡 첫 번째 해결 방법 :  `Eager Loading 방식으로 바꾸기`
        
  최종적으로 워크스페이스 협업자를 DB에 저장하고 싶은 것이므로, Workspace를 통해 연관 Entity인 WorkspaceCollaborator를 즉시 로드할 수 있도록 Eager Loading 방식을 사용하였다.
        
        // 수정한 코드
  
        @Builder
        @Entity
        @Getter
        @NoArgsConstructor
        @AllArgsConstructor
        public class Workspace extends Timestamped {
                       .
                       .
                       .
            @Builder.Default
            @OneToMany(mappedBy = "workspace", fetch = FetchType.EAGER)
            private List<WorkspaceCollaborator> workspaceCollaborators = new ArrayList<>();
        
        성공적으로 DB에 협업자가 등록된다!
        <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/b3f78952-a6ab-46d7-bf95-d02421a374c4">

        
* ⚠️ 첫 번째 해결방법의 문제점<br><br> : 위와 같이 WorkspaceCollaborator Entity를 Eager Loading 방식으로 설정했을 때 `JPA N+1 문제`로 인한 성능 이슈가 발생할 수 있다.<br>즉, 하나의 Workspace만 조회를 해도 각각의 Workspace가 가진 WorkspaceCollaborator 모두를 조회하는 것이다.

<br>
    
* 💡 두 번째 해결책 : `JPQL의 JOIN FETCH 및 Fetch Join 전략 사용하기`
  
  연관 엔티티와 함께 현재 엔티티를 로딩함으로, Lazy Loading 방식을 사용하면서 발생한 `WorkspaceCollaborator DB에 접근하는 것을 지연되어 협업 멤버가 DB에 Save되지 않는 문제`를 해결할 수 있다.
        
  다소 쿼리 문이 복잡해질 가능성이 있지만 우리가 직면한 상황에서는 이것이 문제가 되지는 않는다.
        
        public Workspace findWpById(Long wpId) {
            return wpRepository.findByIdWithCollaborators(wpId).orElseThrow(() ->
                new CustomException(CustomErrorCode.WORKSPACE_NOT_FOUND));
        }
        
  뿐만 아니라 Eager Loading 방식을 사용하였을 때 발생하는 불필요한 데이터까지 로딩되는 문제, 그리고 아래와 같이 JOIN을 통해 하나의 쿼리 문으로 작동하기 때문에 N+1 쿼리 문제까지 해결이 된다.
        
        SELECT w FROM Workspace w
        JOIN FETCH w.workspaceCollaborators
        WHERE w.id = :wpId
                
    
* 💡 세 번째 해결책 : `Lazy Loading 방식을 사용하면서 Transaction 내에서 필드에 접근하기`
        
        성능을 높이기 위해 필요한 경우에만 데이터를 로드하는 Lazy Loading 방식을 유지하면서, workspaceCollaborator 필드에 접근하는 로직 추가하면 어떨까?
        
        // 수정한 코드
        @Builder
        @Entity
        @Getter
        @NoArgsConstructor
        @AllArgsConstructor
        public class Workspace extends Timestamped {
                       .
                       .
                       .
            @Builder.Default
            @OneToMany(mappedBy = "workspace") // default가 LAZY
            private List<WorkspaceCollaborator> workspaceCollaborators = new ArrayList<>();
                       .
                       .
                       .
            // Lazy Loading을 강제로 발생시켜 workspaceCollaborator 필드를 로드하는 메서드
            public List<WorkspaceCollaborator> loadWorkspaceCollaborators() {
                if (this.workspaceCollaborators == null) {
                    // Lazy Loading을 발생시키기 위해 size() 메서드를 호출
                    this.workspaceCollaborators.size();
                }
                return this.workspaceCollaborators;
            }
        }
        
  loadWorkspaceCollaborators 메서드 호출이 Lazy Loading을 강제로 발생시켜 데이터베이스에서 연관된 workspaceCollaborators 정보를 로드하고 성공적으로 workspaceCollaborator db에 접근할 수 있게 된다.
        
        @Service
        @RequiredArgsConstructor
        public class WpColService {
                                     .
                                     .
                                     .
            public void autoInviteWpCol(User user, Long wpId) {
                Workspace foundWorkspace = findWpById(wpId);
        
                // workspaceCollaborators 필드를 로드하여 Lazy Loading을 강제로 발생시키기
                foundWorkspace.loadWorkspaceCollaborators();
        
                // 이미 등록된 사용자 초대당하기 불가
                if (wpColRepository.existsByWorkspaceAndEmail(foundWorkspace, user.getEmail())) {
                    throw new CustomException(CustomErrorCode.WORKSPACE_COLLABORATOR_ALREADY_EXISTS);
                }
        
                // 워크스페이스 협업자로 등록
                User invitedUser = findUser(user.getEmail());
                WorkspaceCollaborator newWpCol = WpColRequestDto.toEntity(invitedUser, foundWorkspace);
        
                // 아이디 수동 할당 - 데이터가 덮어 씌어지는 문제 방지
                newWpCol.assignNewId();
                wpColRepository.save(newWpCol);
            }
        
<br>
    
* ⚠️ 고민<br>
      연관 엔티티를 단순히 저장하고자 하는 상황에서 Fetch Join 방식과 Transaction 내에서 필드에 접근하여 데이터를 로드하는 방식 중 무엇이 더 우리 프로젝트에 적합한 방법일까?<br><br>둘의 차이점은 코드가 실행되는 위치가 다르다는 것이다.<br><br>우선 Fetch Join 방식은 데이터 레벨에서 동작하며 속도가 빠르다는 장점이 있다. 반면, 트랜잭션 내 필드 접근을 통한 Lazy Loading 방식은 JVM에서 동작한다는 차이가 있다.
  
<br>

* ➡️ 결론<br>
      첫째, 연관 엔티티를 단순히 저장하는 행위는 빠른 처리 속도가 필요하지 않다.<br><br>
      둘째, 우리 프로젝트는 추후 작업될 동시성 문제와 관련하여 프로젝트의 전체적인 처리 속도가 중요하므로, 다른 작업에서는 최대한 데이터베이스에 부하를 주지 않는 것이 좋다.<br><br>Lazy Loading 방식을 사용함으로써 발생한 문제를 해결하기 위해, 앞선 두 가지 논거를 들어 세 번째 해결 방법에 해당하는 트랜잭션 내 필드 접근을 통한 방식을 사용하겠다는 결론을 내렸다.
  
  <br>
  
</div>
</details>
  
<br><br>
